\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage{float}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{shapes, automata, positioning}
\usepackage{circuitikz}

\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
}

% Code blocks
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\begin{document}
\input{title.tex}

\tableofcontents
\pagebreak

\section{Specifiche}
Si progetti un dispositivo per la gestione di partite di \textbf{Morra Cinese}, conosciuta anche come "sasso-carta-forbici".
Il dispositivo dovrà essere modellato come un circuito sequenziale FSMD (Finite State Machine + Datapath) in Sis e Verilog.
Si considerino due giocatori che inseriscono una mossa che può essere sasso, carta o forbici.
Ogni partita è composta da più manche e ad ogni manche il giocatore vincente è decretato dalle seguenti regole:
\begin{itemize}
	\item Sasso batte Forbici
	\item Forbici batte Carta
	\item Carta batte Sasso
\end{itemize}
Nell'eventualità che i due giocatori scelgano la stessa mossa verrà decretato un pareggio.
In aggiunta, ogni partita di \textbf{Morra Cinese} si articola su più manche, con le seguenti regole:
\begin{enumerate}
	\item Si devono giocare un \textbf{minimo} di \textbf{quattro manche};
	\item Si possono giocare un \textbf{massimio} di \textbf{diciannove manche}. Il numero delle stesse viene settato al ciclo di clock in cui viene iniziata la partita;
	\item Vince il primo giocatore che riesce a \textbf{vincere due manche in più del proprio avversario} (avendo giocato le quattro manche \textbf{minime});
	\item Ad ogni manche, il giocatore \textbf{vincente della manche precedente} è tenuto a non ripetere l'ultima mossa utilizzata. Nel caso lo facesse (indipendentemente dal risultato della manche attuale) la manche non sarebbe valida (non sarebbe conteggiata nel \textbf{mancheIdx}) e andrebbe quindi ripetuta;
	\item Ad ogni manche, in caso di pareggio essa \textbf{viene conteggiata}. Alla manche successiva entrambi i giocatori possono usare \textbf{tutte le mosse};
\end{enumerate}
Il circuito ha \textbf{tre ingressi}:
\begin{itemize}
	\item \textbf{PRIMO [2 bit]}: mossa selezionata dal primo giocatore. Le mosse hanno i seguenti codici:
	      \begin{itemize}
		      \item \textbf{00}: Nessuna mossa utilizzata;
		      \item \textbf{01}: Sasso;
		      \item \textbf{10}: Carta;
		      \item \textbf{11}: Forbici;
	      \end{itemize}
	\item \textbf{SECONDO [2 bit]}: mossa selezionata dal secondo giocatore. Le mosse hanno codici identici a quelli del primo giocatore.
	\item \textbf{INIZIA [1 bit]}: quando il valore è uguale ad 1, riporta il sistema alla configurazione iniziale. Inoltre, la concatenazione degli ingressi \textbf{PRIMO} e \textbf{SECONDO} viene utilizzata per stabilire il numero massimo di manche (le \textbf{quattro manche} obbligatorie sommate al \textbf{valore concatenato di PRIMO e SECONDO}).
	      Per fare un esempio inserendo i valori \textbf{PRIMO = 01} e \textbf{SECONDO = 10} si dovrà sommare il numero \textbf{quattro} (in base due) al numero \textbf{0110} ottenendo un massimo di \textbf{dieci manche} per tale partita.
\end{itemize}
Il circuito ha \textbf{due uscite}:
\begin{itemize}
	\item \textbf{MANCHE [2 bit]}: fornisce in output il risultato dell'ultima manche giocata con la seguente codifica:
	      \begin{itemize}
		      \item \textbf{00}: manche non valida;
		      \item \textbf{01}: manche vinta dal giocatore 1;
		      \item \textbf{10}: manche vinta dal giocatore 2;
		      \item \textbf{11}: manche pareggiata;
	      \end{itemize}
	\item \textbf{PARTITA [2 bit]}: fornisce in output il risultato della partita con la seguente codifica:
	      \begin{itemize}
		      \item \textbf{00}: la partita non è ancora terminata;
		      \item \textbf{01}: la partita è terminata, vittoria del \textbf{giocatore 1};
          \item \textbf{10}: la partita è terminata, vittoria del \textbf{giocatore 2};
		      \item \textbf{11}: la partita è terminata in pareggio;
	      \end{itemize}
\end{itemize}
\section{Architettura generale}
Il circuito è costituito da FSM (controllore) e Datapath (elaboratore). 
Nella figura \ref{fig:architettura_generale} è rappresentata l'architettura generale del circuito
che prende in input i segnali \textbf{primo}, \textbf{secondo} e \textbf{inizia} condivisi tra FSM e Datapath e
restituisce in output i segnali \textbf{manche} (dalla FSM) e \textbf{partita} (dal Datapath). Il segnale di
clock è lo stesso per entrambi i componenti.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}
			\draw (0,0) rectangle (2,2) node[pos=.5] {FSM};
			\draw[latex-] (0.25,2) -- ++(0,1) node[above, align=center, scale=0.8] {primo};
			\draw[latex-] (1,2) -- ++(0,1.5) node[above, align=center, scale=0.8] {secondo};
			\draw[latex-] (1.75,2) -- ++(0,1) node[above, align=center, scale=0.8] {inizia};

			\draw[-latex] (1,0) -- ++(0,-1) node[below, align=center, scale=0.8] {manche};


			\draw (4,0) rectangle (6,2) node[pos=.5] {Datapath};
			\draw[latex-] (4.25,2) -- ++(0,1) node[above, align=center, scale=0.8, yshift=-2] {primo};
			\draw[latex-] (5,2) -- ++(0,1.5) node[above, align=center, scale=0.8] {secondo};
			\draw[latex-] (5.75,2) -- ++(0,1) node[above, align=center, scale=0.8] {inizia};

			\draw[-latex] (5,0) -- ++(0,-1) node[below, align=center, scale=0.8] {partita};

			\draw[latex-] (4,1) -- (2,1) node[pos=.5, above, align=center, scale=0.8] {manche};

			\draw[latex-] (0,0.5) -- ++(-0.5,0) -- ++(0,-1) -- ++(-1,0) node[left, align=center, scale=0.8] {CLK};
			\draw[fill] (-0.5,-0.5) circle (0.05);
			\draw[-latex] (-0.5,-0.5) -- (4.5, -0.5) -- ++(0,0.5);

		\end{tikzpicture}
	\end{center}
	\caption{Architettura generale della FSMD}
	\label{fig:architettura_generale}
\end{figure}

\section{Diagramma degli stati del controllore}
È riportata nella tabella \ref{tab:stg} la State Transition Table del controllore con la rappresentazione di Mealy.
Gli ingressi sono codificati nel seguente modo per agevolare la lettura della tabella:
\begin{itemize}
	\item \textbf{Nessuna scelta}: $N = 00$
	\item \textbf{Sasso}: $S = 01$
	\item \textbf{Carta}: $C = 10$
	\item \textbf{Forbice}: $F = 11$
\end{itemize}
e gli stati codificati nel seguente modo:
\begin{itemize}
	\item \textbf{Par}: Pareggio
	\item \textbf{PrS}: Primo giocatore vince con sasso
	\item \textbf{PrC}: Primo giocatore vince con carta
	\item \textbf{PrF}: Primo giocatore vince con forbice
	\item \textbf{SeS}: Secondo giocatore vince con sasso
	\item \textbf{SeC}: Secondo giocatore vince con carta
	\item \textbf{SeF}: Secondo giocatore vince con forbice
\end{itemize}
Dato l'elevato numero di ingressi nella seguente tabella è stato deciso di mettere in riga gli stati e in
colonna gli ingressi per una migliore leggibilità.
\begin{table}[H]
	\centering
	{\renewcommand{\arraystretch}{2}%
		\begin{tabular}{l|c|c|c|c|c|c|c}
			                   & Par    & PrS    & PrC    & PrF    & SeS    & SeC    & SeF    \\
			\hline
			- -\hspace{0.5mm}1 & Par/00 & Par/00 & Par/00 & Par/00 & Par/00 & Par/00 & Par/00 \\
			\hline
			N-\hspace{0.5mm}0  & Par/00 & PrS/00 & PrC/00 & PrF/00 & SeS/00 & SeC/00 & SeF/00 \\
			\hline
			-N\hspace{0.5mm}0  & Par/00 & PrS/00 & PrC/00 & PrF/00 & SeS/00 & SeC/00 & SeF/00 \\
			\hline
			SS\hspace{0.5mm}0  & Par/11 & PrS/00 & Par/11 & Par/11 & SeS/00 & Par/11 & Par/11 \\
			\hline
			SC\hspace{0.5mm}0  & SeC/10 & PrS/00 & SeC/10 & SeC/10 & SeC/10 & SeC/00 & SeC/10 \\
			\hline
			SF\hspace{0.5mm}0  & PrS/01 & PrS/00 & PrS/01 & PrS/01 & PrS/01 & Prs/01 & SeF/00 \\
			\hline
			CS\hspace{0.5mm}0  & PrC/01 & PrC/01 & PrC/00 & PrC/01 & SeS/00 & PrC/01 & PrC/01 \\
			\hline
			CC\hspace{0.0mm}0  & Par/11 & Par/11 & PrC/00 & Par/11 & Par/11 & SeC/00 & Par/11 \\
			\hline
			CF\hspace{0.2mm}0  & SeF/10 & SeF/10 & PrC/00 & SeF/10 & SeF/10 & SeF/10 & SeF/00 \\
			\hline
			FS\hspace{0.5mm}0  & SeS/10 & SeS/10 & SeS/10 & PrF/00 & SeS/00 & SeS/10 & SeS/10 \\
			\hline
			FC\hspace{0.3mm}0  & PrF/01 & PrF/01 & PrF/01 & PrF/00 & PrF/01 & SeC/00 & PrF/01 \\
			\hline
			FF\hspace{0.5mm}0  & Par/11 & Par/11 & Par/11 & PrF/00 & Par/11 & Par/11 & SeF/00 \\
		\end{tabular}}
	\caption{State Transition Table del controllore (Mealy)}
	\label{tab:stg}
\end{table}

\noindent Nella figura \ref{fig:stg} è rappresentato il State Transition Graph del controllore. Per una migliore
leggibilità sono stati omessi gli archi che portano da uno stato in cui vince uno dei due giocatori a tutti gli altri
stati in cui avrebbe vinto un giocatore, si è deciso invece di riportare il nome dello stato prossimo una seconda volta.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=3.7cm,auto]
		\tikzstyle{every state}=[fill={rgb:black,1;white,10}]

		\node[state] (Par)                {$Par$};
		\node (L)   [left of=Par]  {};
		\node (R)   [right of=Par] {};
		\node[state] (PrS) [above of=L]   {$PrS$};
		\node[state] (PrC) [above of=Par] {$PrC$};
		\node[state] (PrF) [above of=R]   {$PrF$};
		\node[state] (SeS) [below of=L]   {$SeS$};
		\node[state] (SeC) [below of=Par] {$SeC$};
		\node[state] (SeF) [below of=R]   {$SeF$};
		\node at (PrS) [xshift=-1.35cm, yshift=1.3cm,align=center,scale=0.7] (prs1) { $\stackrel{\text{CS0/01}}{\text{PrC}}$};
		\node at (PrS) [xshift=-0.45cm, yshift=1.3cm,align=center,scale=0.7] (prs2) { $\stackrel{\text{FC0/01}}{\text{PrF}}$};
		\node at (PrS) [xshift=0.45cm, yshift=1.3cm,align=center,scale=0.7] (prs3) { $\stackrel{\text{FS/10}}{\text{SeS}}$};
		\node at (PrS) [xshift=1.35cm, yshift=1.3cm,align=center,scale=0.7] (prs4) { $\stackrel{\text{CF0/10}}{\text{SeF}}$};
		\node at (PrC) [xshift=-1.35cm, yshift=1.3cm,align=center,scale=0.7] (prc1) { $\stackrel{\text{SF0/01}}{\text{PrS}}$};
		\node at (PrC) [xshift=-0.45cm, yshift=1.3cm,align=center,scale=0.7] (prc2) { $\stackrel{\text{FC0/01}}{\text{PrF}}$};
		\node at (PrC) [xshift=0.45cm, yshift=1.3cm,align=center,scale=0.7] (prc3) { $\stackrel{\text{FS0/10}}{\text{SeS}}$};
		\node at (PrC) [xshift=1.35cm, yshift=1.3cm,align=center,scale=0.7] (prc4) { $\stackrel{\text{SC0/10}}{\text{SeC}}$};
		\node at (PrF) [xshift=-1.35cm, yshift=1.3cm,align=center,scale=0.7] (prf1) { $\stackrel{\text{SF0/01}}{\text{PrS}}$};
		\node at (PrF) [xshift=-0.45cm, yshift=1.3cm,align=center,scale=0.7] (prf2) { $\stackrel{\text{CS0/01}}{\text{PrC}}$};
		\node at (PrF) [xshift=0.45cm, yshift=1.3cm,align=center,scale=0.7] (prf3) { $\stackrel{\text{SC0/10}}{\text{SeC}}$};
		\node at (PrF) [xshift=1.35cm, yshift=1.3cm,align=center,scale=0.7] (prf4) { $\stackrel{\text{CF0/10}}{\text{SeF}}$};
		\node at (SeS) [xshift=-1.35cm, yshift=-1.3cm,align=center,scale=0.7] (ses1) { $\underset{\text{SC0/10}}{\text{SeC}}$};
		\node at (SeS) [xshift=-0.45cm, yshift=-1.3cm,align=center,scale=0.7] (ses2) { $\underset{\text{CF0/10}}{\text{SeF}}$};
		\node at (SeS) [xshift=0.45cm, yshift=-1.3cm,align=center,scale=0.7] (ses3) { $\underset{\text{SF0/01}}{\text{PrS}}$};
		\node at (SeS) [xshift=1.35cm, yshift=-1.3cm,align=center,scale=0.7] (ses4) { $\underset{\text{FC0/01}}{\text{PrF}}$};
		\node at (SeC) [xshift=-1.35cm, yshift=-1.3cm,align=center,scale=0.7] (sec1) { $\underset{\text{FS0/10}}{\text{SeS}}$};
		\node at (SeC) [xshift=-0.45cm, yshift=-1.3cm,align=center,scale=0.7] (sec2) { $\underset{\text{CF0/10}}{\text{SeF}}$};
		\node at (SeC) [xshift=0.45cm, yshift=-1.3cm,align=center,scale=0.7] (sec3) { $\underset{\text{SF0/01}}{\text{PrS}}$};
		\node at (SeC) [xshift=1.35cm, yshift=-1.3cm,align=center,scale=0.7] (sec4) { $\underset{\text{CS0/01}}{\text{PrC}}$};
		\node at (SeF) [xshift=-1.35cm, yshift=-1.3cm,align=center,scale=0.7] (sef1) { $\underset{\text{FS0/10}}{\text{SeS}}$};
		\node at (SeF) [xshift=-0.45cm, yshift=-1.3cm,align=center,scale=0.7] (sef2) { $\underset{\text{SC0/10}}{\text{SeC}}$};
		\node at (SeF) [xshift=0.45cm, yshift=-1.3cm,align=center,scale=0.7] (sef3) { $\underset{\text{CS0/01}}{\text{PrC}}$};
		\node at (SeF) [xshift=1.35cm, yshift=-1.3cm,align=center,scale=0.7] (sef4) { $\underset{\text{FC0/01}}{\text{PrF}}$};

		\path[->]
		(Par) edge [loop left] node[scale=0.6, align=center] {N-0/00\\-N0/00\\--1/00} (   )
		edge [loop right] node[scale=0.6, align=center] {SS0/11\\CC0/11\\FF0/11} (   );
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center] {SF0/01} (PrS)
		(PrS) edge [loop left] node[scale=0.6, align=center] {S-0/00\\N-0/00\\-N0/00} (   )
		(PrS) edge [bend left=10] node[scale=0.6, align=center, xshift=-6] {CC0/11\\FF0/11\\--1/00} (Par);
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center, xshift=2] {CS0/01} (PrC)
		(PrC) edge [loop left] node[scale=0.6, align=center] {C-0/00\\N-0/00\\-N0/00} (   )
		(PrC) edge [bend left=10] node[scale=0.6, align=center, yshift=30] {SS0/11\\FF0/11\\--1/00} (Par);
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center, yshift=30, xshift=35] {FC0/01} (PrF)
		(PrF) edge [loop right] node[scale=0.6, align=center] {F-0/00\\N-0/00\\-N0/00} (   )
		(PrF) edge [bend left=10] node[scale=0.6, align=center] {SS0/11\\CC0/11\\--1/00} (Par);
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center, yshift=-20, xshift=-22] {FS0/10} (SeS)
		(SeS) edge [loop left] node[scale=0.6, align=center] {S-0/00\\N-0/00\\-N0/00} (   )
		(SeS) edge [bend left=10] node[scale=0.6, align=center] {CC0/11\\FF0/11\\--1/00} (Par);
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center] {SC0/10} (SeC)
		(SeC) edge [loop left] node[scale=0.6, align=center] {C-0/00\\N-0/00\\-N0/00} (   )
		(SeC) edge [bend left=10] node[scale=0.6, align=center, yshift=-15] {SS0/11\\FF0/11\\--1/00} (Par);
		\path[->]
		(Par) edge [bend left=10] node[scale=0.6, align=center] {CF0/10} (SeF)
		(SeF) edge [loop right] node[scale=0.6, align=center] {F-0/00\\N-0/00\\-N0/00} (   )
		(SeF) edge [bend left=10] node[scale=0.6, align=center, yshift=-12, xshift=20] {SS0/11\\CC0/11\\--1/00} (Par);

		\path[->]
		(PrS) edge [] node[scale=0.7, align=center] {} (prs1)
		(PrS) edge [] node[scale=0.7, align=center] {} (prs2)
		(PrS) edge [] node[scale=0.7, align=center] {} (prs3)
		(PrS) edge [] node[scale=0.7, align=center] {} (prs4);
		\path[->]
		(PrC) edge [] node[scale=0.7, align=center] {} (prc1)
		(PrC) edge [] node[scale=0.7, align=center] {} (prc2)
		(PrC) edge [] node[scale=0.7, align=center] {} (prc3)
		(PrC) edge [] node[scale=0.7, align=center] {} (prc4);
		\path[->]
		(PrF) edge [] node[scale=0.7, align=center] {} (prf1)
		(PrF) edge [] node[scale=0.7, align=center] {} (prf2)
		(PrF) edge [] node[scale=0.7, align=center] {} (prf3)
		(PrF) edge [] node[scale=0.7, align=center] {} (prf4);
		\path[->]
		(SeS) edge [] node[scale=0.7, align=center] {} (ses1)
		(SeS) edge [] node[scale=0.7, align=center] {} (ses2)
		(SeS) edge [] node[scale=0.7, align=center] {} (ses3)
		(SeS) edge [] node[scale=0.7, align=center] {} (ses4);
		\path[->]
		(SeC) edge [] node[scale=0.7, align=center] {} (sec1)
		(SeC) edge [] node[scale=0.7, align=center] {} (sec2)
		(SeC) edge [] node[scale=0.7, align=center] {} (sec3)
		(SeC) edge [] node[scale=0.7, align=center] {} (sec4);
		\path[->]
		(SeF) edge [] node[scale=0.7, align=center] {} (sef1)
		(SeF) edge [] node[scale=0.7, align=center] {} (sef2)
		(SeF) edge [] node[scale=0.7, align=center] {} (sef3)
		(SeF) edge [] node[scale=0.7, align=center] {} (sef4);
	\end{tikzpicture}
	\caption{State Transition Graph del controllore}
	\label{fig:stg}
\end{figure}


\section{Architettura del datapath}
I componenti che sono stati utilizzati per l'elaborazione del circuito sono i seguenti, presentati sottoforma di \textbf{Nome Componente} e \textbf{Numero di Occorrenze}.

\begin{itemize}
	\item \textbf{Registro a 5 bit}: 2

	      \noindent Utilizzati per salvare in memoria i valori di:
	      \begin{itemize}
		      \item \textbf{mancheIdx}: Indice della manche corrente;
		      \item \textbf{maxManche}: Numero massimo di manche che possono essere giocate in una singola partita;
	      \end{itemize}
	\item \textbf{Registro a 4 bit}: 1

	      \noindent Utilizzato per salvare in memoria il valore di \textbf{vantaggio}. Il vantaggio è codificato in complemento
	      a 2 in modo da poter calcolare il vantaggio di entrambi i giocatori con un singolo registro. Quando il
	      vantaggio assume valori positivi è il giocatore 1 ad avere il vantaggio, quando assume valori negativi
	      è il giocatore 2 ad avercelo.
	\item \textbf{Mux a 4 Ingressi da 5 bit}: 1

	      \noindent Utilizzato per incrementare il \textbf{mancheIdx} durante la partita solo nel caso in cui la manche
	      risulti valida. Il Mux dà in output \( 00001 \) se la manche è valida, \( 00000 \) altrimenti.
	\item \textbf{Mux a 4 Ingressi da 4 bit}: 1

	      \noindent Utilizzato per incrementare o decrementare il valore di \textbf{vantaggio}. Il Mux dà in output
	      \( 0001 \) se il giocatore 1 ha vinto la manche, \( 1111 \) se il giocatore 2 ha vinto la manche,
	      \( 0000 \) altrimenti. Visto che vantaggio è codificato in complemento a 2, il valore \( 1111 \) equivale
	      a \( -1_{10} \).
	\item \textbf{Mux a 2 Ingressi da 5 bit}: 2

	      \noindent Utilizzati per decidere quale valore inserire all'interno dei registri di \textbf{mancheIdx}
	      e \textbf{maxManche}. Il Mux inizializza i registri con il valore \( 00000 \) se il valore di \textbf{inizia}
	      è uguale a \( 1 \), altrimenti inserisce il nuovo valore di \textbf{mancheIdx} e \textbf{maxManche} in input.
	\item \textbf{Mux a 2 Ingressi da 4 bit}: 1

	      \noindent Utilizzato per decidere quale valore inserire all'interno del registro di \textbf{vantaggio}.
	      Il Mux inizializza il registro con il valore \( 0000 \) se il valore di \textbf{inizia} è uguale a \( 1 \),
	      altrimenti inserisce il nuovo valore di \textbf{vantaggio} in input.
	\item \textbf{Mux a 2 Ingressi da 2 bit}: 2

	      \noindent Utilizzati nel componente \textbf{Partita}. I due Mux insieme determinano quale valore di
	      \textbf{partita} dovrà essere stampato in \textbf{output}.
	\item \textbf{Sommatore a 5 bit}: 3

	      \noindent Utilizzati per sommare 2 numeri e fornire in output un numero a 5 bit.
	      Il loro scopo è determinare e modificare il valore di \textbf{maxManche} e \textbf{mancheIdx}.
	\item \textbf{Sommatore a 4 bit}: 1

	      \noindent Utilizzato per sommare 2 numeri e fornire in output un numero a 4 bit.
	      La sua funzione è modificare il valore di \textbf{vantaggio}.
	\item \textbf{And}: 2

	      \noindent Utilizzati per verificare se due condizioni sono vere allo stesso tempo. Si trovano nel componente \textbf{Partita} del Datapath.
	\item \textbf{Maggiore uguale da 5 bit}: 2

	      \noindent Utilizzati rispettivamente per confrontare il valore di \textbf{mancheIdx} e \textbf{maxManche},
	      e per controllare se il valore di \textbf{mancheIdx} è maggiore o uguale a \( 4 \).
	\item \textbf{Maggiore uguale da 4 bit}: 4

	      \noindent Utilizzati per comparare il valore di \textbf{vantaggio} con alcune \textbf{Costanti}. Questo
	      componente è stato progettato per tenere in considerazione la codifica in complemento a 2 di \textbf{vantaggio}.
	\item \textbf{Concatenatore a 2 ingressi da 2 bit con uscita a 5 bit}: 1

	      \noindent Utilizzato per concatenare il valore di \textbf{primo} e \textbf{secondo} in modo da poter
	      avere un unico valore a 5 bit (aggiungendo uno 0 come bit più significativo) per poter calcolare \textbf{maxManche}.
	\item \textbf{Concatenatore a 2 ingressi da 1 bit con uscita a 2 bit}: 2

	      \noindent Utilizzati per concatenare i valori di controllo per determinare il vincitore della partita.
\end{itemize}

\noindent Nella figura \ref{fig:datapath} è rappresentato il Datapath del circuito.

\begin{figure}[H]
	\centering
	\begin{circuitikz}[square/.style={regular polygon,regular polygon sides=4}]
		% Multiplexer 2 to 1
		\draw (-1.4,-1) node (1mux2-0) {0};
		\draw (-0.9,-1) node (1mux2-1) {1};
		\draw (-1.4,-0.8) node (1mux2-i0) {};
		\draw (-0.9,-0.8) node (1mux2-i1) {};
		\draw (-0.6,-1) node (1mux2-s) {};
		\draw (-1.15,-1.18) node (1mux2-o) {};
		\draw (-1.9,-0.7) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Multiplexer2 2 to 1
		\draw (-1.4,-5) node (2mux2-0) {0};
		\draw (-0.9,-5) node (2mux2-1) {1};
		\draw (-1.4,-4.8) node (2mux2-i0) {};
		\draw (-0.9,-4.8) node (2mux2-i1) {};
		\draw (-0.6,-5) node (2mux2-s) {};
		\draw (-1.15,-5.18) node (2mux2-o) {};
		\draw (-1.9,-4.7) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Multiplexer3 2 to 1
		\draw (1.9,-5) node (3mux2-0) {0};
		\draw (1.4,-5) node (3mux2-1) {1};
		\draw (1.9,-4.8) node (3mux2-i0) {};
		\draw (1.4,-4.8) node (3mux2-i1) {};
		\draw (1.1,-5) node (3mux2-s) {};
		\draw (1.65,-5.18) node (3mux2-o) {};
		\draw (0.9,-4.7) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Multiplexer 4 to 1
		\draw (-5.9,-1) node (1mux4-0) {00};
		\draw (-5.2,-1) node (1mux4-1) {01};
		\draw (-4.5,-1) node (1mux4-2) {10};
		\draw (-3.8,-1) node (1mux4-3) {11};
		\draw (-5.9,-0.8) node (1mux4-i0) {};
		\draw (-5.2,-0.8) node (1mux4-i1) {};
		\draw (-4.5,-0.8) node (1mux4-i2) {};
		\draw (-3.8,-0.8) node (1mux4-i3) {};
		\draw (-6.3,-1) node (1mux4-s) {};
		\draw (-4.95,-1.18) node (1mux4-o) {};
		\draw (-6.5,-0.7) -- ++(3.3,0) -- ++(-0.25, -0.6) -- ++(-2.8,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Multiplexer2 4 to 1
		\draw (-5.9,-5) node (2mux4-0) {00};
		\draw (-5.2,-5) node (2mux4-1) {01};
		\draw (-4.5,-5) node (2mux4-2) {10};
		\draw (-3.8,-5) node (2mux4-3) {11};
		\draw (-5.9,-4.8) node (2mux4-i0) {};
		\draw (-5.2,-4.8) node (2mux4-i1) {};
		\draw (-4.5,-4.8) node (2mux4-i2) {};
		\draw (-3.8,-4.8) node (2mux4-i3) {};
		\draw (-6.3,-5) node (2mux4-s) {};
		\draw (-4.95,-5.18) node (2mux4-o) {};
		\draw (-6.5,-4.7) -- ++(3.3,0) -- ++(-0.25, -0.6) -- ++(-2.8,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Registri
		% mancheIdx
		\draw (-1.15,-2.5) node[rectangle ,draw, minimum width=2.3cm, minimum height=0.7cm, scale=0.7] (mancheIdx) {\hspace{0.5em}mancheIdx};
		\draw (mancheIdx.west) -- ++(0.005,0) -- ++(0,0.15) -- ++(0.2, -0.15) -- ++(-0.2,-0.15);
		\draw[latex-] (mancheIdx.west) -- ++(-0.5,0) node[above] {\tiny CLK};

		% vantaggio
		\draw (-1.15,-6.5) node[rectangle ,draw, minimum width=2.3cm, minimum height=0.7cm, scale=0.7] (vantaggio) {\hspace{0.5em}vantaggio};
		\draw (vantaggio.west) -- ++(0.005,0) -- ++(0,0.15) -- ++(0.2, -0.15) -- ++(-0.2,-0.15);
		\draw[latex-] (vantaggio.west) -- ++(-0.5,0) node[above] {\tiny CLK};

		% maxManche
		\draw (1.65,-6.5) node[rectangle ,draw, minimum width=2.5cm, minimum height=0.7cm, scale=0.7] (maxManche) {\hspace{-0.5em}maxManche};
		\draw (maxManche.east) -- ++(-0.005,0) -- ++(0,0.15) -- ++(-0.2, -0.15) -- ++(0.2,-0.15);
		\draw[latex-] (maxManche.east) -- ++(0.5,0) node[above] {\tiny CLK};
		% ------------------

		% Operatori
		\draw (-2.9,-3.4) node[square,draw, minimum size=2cm, scale=0.6] (sum1) {\huge$+$};
		\node[xshift=-5, yshift=-3] at (sum1.north) (sum1-i0) {};
		\node[xshift=5, yshift=-3] at (sum1.north) (sum1-i1) {};

		\draw (-2.9,-7.4) node[square,draw, minimum size=2cm, scale=0.6] (sum2) {\huge$+$};
		\node[xshift=-5, yshift=-3] at (sum2.north) (sum2-i0) {};
		\node[xshift=5, yshift=-3] at (sum2.north) (sum2-i1) {};

		\draw (3.5,-7.4) node[square,draw, minimum size=2cm, scale=0.6] (sum3) {\huge$+$};
		\node[xshift=-5, yshift=-3] at (sum3.north) (sum3-i0) {};
		\node[xshift=5, yshift=-3] at (sum3.north) (sum3-i1) {};

		\draw (3mux2-i1 |- 52,-3.5) node[square,draw, minimum size=2cm, scale=0.6] (sum4) {\huge$+$};
		\node[xshift=-5, yshift=-3] at (sum4.north) (sum4-i0) {};
		\node[xshift=5, yshift=-3] at (sum4.north) (sum4-i1) {};

		\draw (sum4-i1 |- 52,-1.5) node[square,draw, minimum size=2cm, scale=0.6] (conc) {\huge$C$};
		\node[xshift=-5, yshift=-3] at (conc.north) (conc-i0) {};
		\node[xshift=5, yshift=-3] at (conc.north) (conc-i1) {};
		% ------------------

		% Componenti
		\draw (0.3,-8.5) node[rectangle ,draw, minimum width=2.5cm, minimum height=1cm, scale=0.7] (partita) {Partita};
		\node[xshift=-15, yshift=-3] at (partita.north) (partita-i0) {};
		\node[xshift=-5, yshift=-3] at (partita.north) (partita-i1) {};
		\node[xshift=5, yshift=-3] at (partita.north) (partita-i2) {};
		\node[xshift=15, yshift=-3] at (partita.north) (partita-i3) {};
		% ------------------

		% inizia
		\draw[-latex] (0.3,0) node[above] (inizia) {\scriptsize inizia} -- ++(0,-1) -- (1mux2-s);
		\draw[fill] (0.3,-1) circle (0.03);
		\draw[-latex] (0.3,-1) -- ++(0,-1) |- (2mux2-s);
		\draw[fill] (0.3,52 |- 2mux2-s) circle (0.03);
		\draw[-latex] (0.3,52 |- 3mux2-s) -- (3mux2-s);

		% primo
		\draw[-latex] (1.2,0) node[above, yshift=-1.5] (inizia) {\scriptsize primo} -- ++(0,-0.8) -| (conc-i0);

		% secondo
		\draw[-latex] (1.93,0) node[above, xshift=8] (inizia) {\scriptsize secondo} -- ++(0,-0.8) -| (conc-i1);

		% manche
		\draw[latex-] (1mux4-s) -- ++(-1,0) node[below, yshift=-1, xshift=-5] (manche) {\scriptsize manche};
		\draw[latex-] (2mux4-s) -- ++(-0.5,0) -- (-6.8, 52 |- 1mux4-s);
		\draw[fill] (-6.8, 52 |- 1mux4-s) circle (0.03);

		% mancheIdx
		\draw[latex-] (1mux2-i1) -- ++(0,0.5) node[above] {\tiny 00000};
		\draw[-latex] (1mux2-o) -- (mancheIdx.north);
		\draw[-latex] (mancheIdx.south) -- ++(0,-0.5) |- (sum1.east);
		\draw[-latex] (sum1.north) -- ++(0,2.7) -| (1mux2-i0);
		\draw[-latex] (1mux4-o) |- (sum1.west);

		\draw[latex-] (1mux4-i0) -- ++(0,0.5) node[above] {\tiny 00000};
		\draw[latex-] (1mux4-i1) -- ++(0,0.5) node[above] {\tiny 00001};
		\draw[latex-] (1mux4-i2) -- ++(0,0.5) node[above] {\tiny 00001};
		\draw[latex-] (1mux4-i3) -- ++(0,0.5) node[above] {\tiny 00001};

		% vantaggio
		\draw[latex-] (2mux2-i1) -- ++(0,0.5) node[above] {\tiny 0000};
		\draw[-latex] (2mux2-o) -- (vantaggio.north);
		\draw[-latex] (vantaggio.south) -- ++(0,-0.5) |- (sum2.east);
		\draw[-latex] (sum2.north) -- ++(0,2.7) -| (2mux2-i0);
		\draw[-latex] (2mux4-o) |- (sum2.west);

		\draw[latex-] (2mux4-i0) -- ++(0,0.5) node[above] {\tiny 0000};
		\draw[latex-] (2mux4-i1) -- ++(0,0.5) node[above] {\tiny 0001};
		\draw[latex-] (2mux4-i2) -- ++(0,0.5) node[above] {\tiny 1111};
		\draw[latex-] (2mux4-i3) -- ++(0,0.5) node[above] {\tiny 0000};

		% maxManche
		\draw[-latex] (3mux2-o) -- (maxManche.north);
		\draw[-latex] (maxManche.south) -- ++(0,-0.5) |- (sum3.west);
		\draw[-latex] (sum3.north) -- ++(0,2.7) -| (3mux2-i0);

		\draw[-latex] (sum4.south) -- (3mux2-i1);
		\draw[latex-] (sum4-i0) -- ++(0,0.5) node[above, xshift=-2] {\tiny 00100};
		\draw[-latex] (conc.south) -- (sum4-i1);

		% partita
		\draw[latex-] (partita-i0) -- ++(0,2.5) -- ++(-0.93,0);
		\draw[fill] (-1.15, -5.75) circle (0.03);
		\draw[latex-] (partita-i1) -- ++(0,6.5) -- ++(-1.28,0);
		\draw[fill] (-1.15, -1.75) circle (0.03);
		\draw[latex-] (partita-i2) -- ++(0,2.5) -- ++(1.18,0);
		\draw[fill] (1.65, -5.75) circle (0.03);
		\draw[-latex] (0.3,52 |- 3mux2-s) -- ++(0,-2) -| (partita-i3);
		\draw[-latex] (partita.south) -- ++(0,-0.6) node[below] {\scriptsize partita};

		% Numero di bit
		% inizia
		\draw (0.2, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};

		% primo
		\draw (1.1, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};

		% secondo
		\draw (1.83, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};

		% concatenatore
		\draw (1.48, -2.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};

		% manche
		\draw (-7.2, -1.1) -- ++(0.2, 0.2) node[above, yshift=-1, xshift=-2] {\tiny 2};

		% mancheIdx
		% 1mux2
		\draw (-1.25, -1.6) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% reg
		\draw (-1.25, -3.1) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% sum
		\draw (-3, -2.8) -- ++(0.2, 0.2) node[left, yshift=-2, xshift=-3] {\tiny 5};
		% 1mux4
		\draw (-5.05, -1.6) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};

		% maxManche
		% sum
		\draw (1.3, -4.3) -- ++(0.2, 0.2) node[left, yshift=-2, xshift=-3] {\tiny 5};
		% 3mux2
		\draw (1.55, -5.6) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% reg
		\draw (1.55, -7.1) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% sum
		\draw (3.4, -6.8) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};

		% vantaggio
		% 2mux2
		\draw (-1.25, -5.6) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 4};
		% reg
		\draw (-1.25, -7.1) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 4};
		% sum
		\draw (-3, -6.8) -- ++(0.2, 0.2) node[left, yshift=-2, xshift=-3] {\tiny 4};
		% 2mux4
		\draw (-5.05, -5.6) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 4};

		% partita
		\draw (0.2, -9.15) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};
		% ------------------
	\end{circuitikz}
	\caption{Architettura del datapath}
	\label{fig:datapath}
\end{figure}

\noindent Per una maggiore leggibilità del circuito è stata modellata una parte all'interno del componente \textbf{Partita} che
riceve in input:
\begin{itemize}
	\item vantaggio;
	\item mancheIdx;
	\item maxManche;
	\item inizia;
\end{itemize}
e fornisce in output:
\begin{itemize}
	\item partita.
\end{itemize}

\noindent Nella figura \ref{fig:partita} è rappresentato il componente \textbf{Partita}.

\begin{figure}[H]
	\centering
	\begin{circuitikz}[square/.style={regular polygon,regular polygon sides=4}]
		\draw (0,0) node[rectangle ,draw, minimum width=2.5cm, minimum height=1cm, scale=1.6] (partita) {Partita};
		\node[xshift=-40, yshift=-3] at (partita.north) (partita-i0) {};
		\node[xshift=-15, yshift=-3] at (partita.north) (partita-i1) {};
		\node[xshift=15, yshift=-3] at (partita.north) (partita-i2) {};
		\node[xshift=40, yshift=-3] at (partita.north) (partita-i3) {};

		\draw[latex-] (partita-i0) -- ++(0,2) node[above] {vantaggio};
		\draw[latex-] (partita-i1) -- ++(0,1.5) node[above, xshift=3] {mancheIdx};
		\draw[latex-] (partita-i2) -- ++(0,1) node[above] {maxManche};
		\draw[latex-] (partita-i3) -- ++(0,0.5) node[above] {inizia};
		\draw[-latex] (partita.south) -- ++(0,-1) node[below] {partita};

	\end{circuitikz}
	\caption{Componente Partita}
	\label{fig:partita}
\end{figure}

\noindent Nella figura \ref{fig:partita_datapath} è rappresentato il datapath del componente \textbf{Partita}.

\begin{figure}[H]
	\centering
	\begin{circuitikz}[square/.style={regular polygon,regular polygon sides=4}]
		% Multiplexer 2 to 1
		\draw (3,-8) node (1mux2-0) {0};
		\draw (2.5,-8) node (1mux2-1) {1};
		\draw (3,-7.8) node (1mux2-i0) {};
		\draw (2.5,-7.8) node (1mux2-i1) {};
		\draw (3.3,-8) node (1mux2-s) {};
		\draw (2.75,-8.18) node (1mux2-o) {};
		\draw (2,-7.7) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Multiplexer2 2 to 1
		\draw (2.75,-9.5) node (2mux2-1) {0};
		\draw (3.25,-9.5) node (2mux2-0) {1};
		\draw (2.75,-9.3) node (2mux2-i0) {};
		\draw (3.25,-9.3) node (2mux2-i1) {};
		\draw (3.55,-9.5) node (2mux2-s) {};
		\draw (3,-9.68) node (2mux2-o) {};
		\draw (2.25,-9.2) -- ++(1.5,0) -- ++(-0.25, -0.6) -- ++(-1,0) -- ++(-0.25,0.6) -- cycle;
		% ------------------

		% Operatori
		\draw (-0.7,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt1) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt1.north) (gt1-i0) {};
		\node[xshift=5, yshift=-3] at (gt1.north) (gt1-i1) {};

		\draw (0.7,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt2) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt2.north) (gt2-i0) {};
		\node[xshift=5, yshift=-3] at (gt2.north) (gt2-i1) {};

		\draw (2.1,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt3) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt3.north) (gt3-i0) {};
		\node[xshift=5, yshift=-3] at (gt3.north) (gt3-i1) {};

		\draw (3.5,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt4) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt4.north) (gt4-i0) {};
		\node[xshift=5, yshift=-3] at (gt4.north) (gt4-i1) {};

		\draw (4.9,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt5) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt5.north) (gt5-i0) {};
		\node[xshift=5, yshift=-3] at (gt5.north) (gt5-i1) {};

		\draw (6.3,-2.5) node[square,draw, minimum size=2cm, scale=0.6] (gt6) {\huge$\ge$};
		\node[xshift=-5, yshift=-3] at (gt6.north) (gt6-i0) {};
		\node[xshift=5, yshift=-3] at (gt6.north) (gt6-i1) {};

		\draw (0,-4.5) node[square,draw, minimum size=2cm, scale=0.6] (conc1) {\huge$C$};
		\node[xshift=-5, yshift=-3] at (conc1.north) (conc1-i0) {};
		\node[xshift=5, yshift=-3] at (conc1.north) (conc1-i1) {};

		\draw (3,-6) node[square,draw, minimum size=2cm, scale=0.6] (conc2) {\huge$C$};
		\node[xshift=-5, yshift=-3] at (conc2.north) (conc2-i0) {};
		\node[xshift=5, yshift=-3] at (conc2.north) (conc2-i1) {};
		% ------------------

		% vantaggio
		\draw (0,0) node[above] (inizia) {\scriptsize vantaggio} -- ++(0,-1.5);
		\draw[-latex] (0,-1.5) -- ++(-0.5,0) -| (gt1-i1);
		\draw[latex-] (gt1-i0) -- ++(0,0.5) node[above] {\tiny 0000};

		\draw[-latex] (0,-1.5) -- ++(0.5,0) -| (gt2-i0);
		\draw[latex-] (gt2-i1) -- ++(0,0.5) node[above] {\tiny 0000};
		\draw[fill] (0,-1.5) circle (0.03);

		\draw[-latex] (gt1.south) -- ++(0,-0.5) -| (conc1-i0);
		\draw[-latex] (gt2.south) -- ++(0,-0.5) -| (conc1-i1);

		\draw[latex-] (gt3-i0) -- ++(0,0.5) node[above] {\tiny $\stackrel{-2}{1110}$};
		\draw[latex-] (gt4-i1) -- ++(0,0.5) node[above] {\tiny $\stackrel{2}{0010}$};
		\draw[latex-] (gt3-i1) -- ++(0,0.5) -- ++(0.5,0);
		\draw[latex-] (gt4-i0) -- ++(0,0.5) -- ++(-0.5,0);
		\draw[fill] (2.8,-1.68) circle (0.03);
		\draw (2.8,-1.68) |- (0,-0.5);
		\draw[fill] (0,-0.5) circle (0.03);

		\node[and port, scale=0.6, rotate=-90, anchor=in 2] at (gt3.south |- 52,-4) (and1) {};
		\node[and port, scale=0.6, rotate=-90, anchor=in 2] at (gt4.south |- 52,-4) (and2) {};

		\draw (gt3.south) -- (and1.in 2);
		\draw (gt4.south) -- (and2.in 2);

		\draw[-latex] (and1.out) -- ++(0,-0.3) -| (conc2-i0);
		\draw[-latex] (and2.out) -- ++(0,-0.3) -| (conc2-i1);

		% mancheIdx and maxManche
		\draw[latex-] (gt5-i1) -- ++(0,0.5) node[above, xshift=2] {\tiny $\stackrel{4}{00100}$};
		\draw[latex-] (gt5-i0) -- (gt5-i0 |- 52, 0) node[above] {\scriptsize mancheIdx};

		\draw[latex-] (gt6-i1) -- (gt6-i1 |- 52, 0) node[above] {\scriptsize maxManche};
		\draw[latex-] (gt6-i0) -- ++(0,0.5) |- (gt5-i0 |- 52, -1);
		\draw[fill] (gt5-i0 |- 52, -1) circle (0.03);

		\draw (gt5.south) -- ++(0,-0.5) -- ++(-2,0) -| (and1.in 1);
		\draw (and2.in 1) -- ++(0,0.57);
		\draw[fill] (3.838,-3.43) circle (0.03);

		\draw[-latex] (conc2.south) -| (1mux2-i0);
		\draw[-latex] (conc1.south) -- ++(0,-2) -| (1mux2-i1);

		\draw[-latex] (1mux2-o) -- (2mux2-i0);
		\draw[latex-] (2mux2-i1) -- ++(0,0.5) node[above] {\tiny 00};

		\draw[-latex] (gt6.south) |- (1mux2-s);

		% inizia
		\draw[-latex] (7.8,0) node[above] (inizia) {\scriptsize inizia} |- (2mux2-s);

		\draw[-latex] (2mux2-o) -- ++(0,-1) node[below] {\scriptsize partita};

		% Numero di bit
		% vantaggio 
		\draw (-0.1, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 4};
		% mancheIdx
		\draw (4.63, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% maxManche
		\draw (6.38, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 5};
		% inizia
		\draw (7.7, -0.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};

		% gt
		\draw (-0.8, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (0.6, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (2, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (3.4, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (4.8, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (6.2, -3.3) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};

		% and
		\draw (2.18, -5.1) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};
		\draw (3.58, -5.1) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 1};

		% conc
		\draw (-0.1, -5.25) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};
		\draw (2.9, -6.75) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};

		% mux
		\draw (2.65, -8.7) -- ++(0.2, 0.2) node[left, yshift=-2, xshift=-5] {\tiny 2};
		\draw (2.9, -10.2) -- ++(0.2, 0.2) node[right, yshift=-2] {\tiny 2};

		% ------------------
	\end{circuitikz}
	\caption{Architettura del componente Partita}
	\label{fig:partita_datapath}
\end{figure}

\section{Simulazioni}
Gli ingressi sono: \textbf{primo[1], primo[0], secondo[1], secondo[0], inizia}.\\
Le uscite sono: \textbf{manche[1], manche[0], partita[1], partita[0]}.

\noindent Abbiamo svolto una singola simulazione prendendo in considerazione \textbf{quattro partite},
ognuna con un diverso numero di \textbf{manche massime}. Questa
simulazione è stata generata dal testbench in verilog in modo da verificare che gli output fossero identici
tra il modello in verilog e quello in sis.

\vspace{1em}
\noindent Le partite sono svolte nel seguente modo:
\begin{enumerate}
	\item Partita da 6 manche massime finita in pareggio;
	\item Partita da 5 manche massime vinta dal giocatore 2 con vantaggio \( -1 \);
	\item Partita da 19 manche massime vinta dal giocatore 1 con vantaggio \( +2 \);
	\item Partita da 9 manche massime vinta dal giocatore 1 con vantaggio \( +2 \);
\end{enumerate}
\begin{figure}[H]
  \centering

	\begin{minipage}{\linewidth}
  \centering
		\begin{minipage}{0.45\linewidth}
  \centering
        \begin{tabular}{|c|c|c|c|}
          \hline
          \multicolumn{4}{|c|}{Partita \textbf{1}} \\
          \multicolumn{4}{|c|}{\footnotesize Manche massime: \textbf{6}} \\
          \hline
          \footnotesize \textbf{\#} & \footnotesize \textbf{Primo} & \footnotesize \textbf{Secondo} & \footnotesize \textbf{Van.} \\
          \hline
          1 & Sasso & Carta & \( -1 \)  \\
          (1) & Forbici & Carta & \( -1 \)  \\
          2 & Sasso & Forbici & \( 0 \)  \\
          3 & Forbici & Forbici & \( 0 \)  \\
          4 & Forbici & Carta & \( 1 \)  \\
          5 & Sasso & Carta & \( 0 \)  \\
          6 & Forbici & Forbici & \( 0 \)  \\
          \hline
          \multicolumn{4}{|c|}{\footnotesize \textbf{Pareggio}} \\
          \hline
        \end{tabular}
		\end{minipage}
		\hspace{0.05\linewidth}
		\begin{minipage}{0.45\linewidth}
  \centering
        \begin{tabular}{|c|c|c|c|}
          \hline
          \multicolumn{4}{|c|}{Partita \textbf{2}} \\
          \multicolumn{4}{|c|}{\footnotesize Manche massime: \textbf{5}} \\
          \hline
          \footnotesize \textbf{\#} & \footnotesize \textbf{Primo} & \footnotesize \textbf{Secondo} & \footnotesize \textbf{Van.} \\
          \hline
          1 & Sasso & Forbici & \( 1 \)  \\
          2 & Carta & Sasso & \( 2 \)  \\
          3 & Sasso & Carta & \( 1 \)  \\
          4 & Carta & Forbici & \( 0 \)  \\
          5 & Forbici & Sasso & \( -1 \)  \\
          \hline
          \multicolumn{4}{|c|}{\footnotesize Vittoria: \textbf{Secondo}} \\
          \hline
        \end{tabular}
		\end{minipage}
	\end{minipage}

  \vspace{0.5cm}

	\begin{minipage}{\linewidth}
  \centering
		\begin{minipage}{0.45\linewidth}
  \centering
        \begin{tabular}{|c|c|c|c|}
          \hline
          \multicolumn{4}{|c|}{Partita \textbf{3}} \\
          \multicolumn{4}{|c|}{\footnotesize Manche massime: \textbf{19}} \\
          \hline
          \footnotesize \textbf{\#} & \footnotesize \textbf{Primo} & \footnotesize \textbf{Secondo} & \footnotesize \textbf{Van.} \\
          \hline
          1 & Sasso & Forbici & \( 1 \)  \\
          2 & Carta & Sasso & \( 2 \)  \\
          3 & Forbici & Carta & \( 3 \)  \\
          (3) & Forbici & Sasso & \( 3 \)  \\
          4 & Sasso & Carta & \( 2 \)  \\
          \hline
          \multicolumn{4}{|c|}{\footnotesize Vittoria: \textbf{Primo}} \\
          \hline
        \end{tabular}
		\end{minipage}
		\hspace{0.05\linewidth}
		\begin{minipage}{0.45\linewidth}
  \centering
        \begin{tabular}{|c|c|c|c|}
          \hline
          \multicolumn{4}{|c|}{Partita \textbf{4}} \\
          \multicolumn{4}{|c|}{\footnotesize Manche massime: \textbf{9}} \\
          \hline
          \footnotesize \textbf{\#} & \footnotesize \textbf{Primo} & \footnotesize \textbf{Secondo} & \footnotesize \textbf{Van.} \\
          \hline
          1 & Sasso & Forbici & \( 1 \)  \\
          2 & Carta & Sasso & \( 2 \)  \\
          3 & Forbici & Sasso & \( 1 \)  \\
          4 & Carta & Carta & \( 1 \)  \\
          5 & Forbici & Sasso & \( 0 \)  \\
          6 & Sasso & Forbici & \( 1 \)  \\
          (6) & Sasso & Carta & \( 1 \)  \\
          (6) & Null & Forbici & \( 1 \)  \\
          (6) & Sasso & Forbici & \( 1 \)  \\
          7 & Forbici & Forbici & \( 1 \)  \\
          8 & Carta & Sasso & \( 2 \)  \\
          \hline
          \multicolumn{4}{|c|}{\footnotesize Vittoria: \textbf{Primo}} \\
          \hline
        \end{tabular}
		\end{minipage}
	\end{minipage}
\end{figure}

\subsection{SIS}
Di seguito sono riportati i file di input e di output di sis per la simulazione.
\begin{figure}[H]
	\centering
	\begin{minipage}{\linewidth}
		\centering
		\begin{minipage}{0.45\linewidth}
			\textbf{testbench.script}:
			\begin{lstlisting}[language=bash]

        read_blif FSMD.blif
        simulate 0 0 1 0 1
        simulate 0 1 1 0 0
        simulate 1 1 1 0 0
        simulate 0 1 1 1 0
        simulate 1 1 1 1 0
        simulate 1 1 1 0 0
        simulate 0 1 1 0 0
        simulate 1 1 1 1 0
        simulate 0 0 0 1 1
        simulate 0 1 1 1 0
        simulate 1 0 0 1 0
        simulate 0 1 1 0 0
        simulate 1 0 1 1 0
        simulate 1 1 0 1 0
        simulate 1 1 1 1 1
        simulate 0 1 1 1 0
        simulate 1 0 0 1 0
        simulate 1 1 1 0 0
        simulate 1 1 0 1 0
        simulate 0 1 1 0 0
        simulate 0 1 0 1 1
        simulate 0 1 1 1 0
        simulate 1 0 0 1 0
        simulate 1 1 0 1 0
        simulate 1 0 1 0 0
        simulate 1 1 0 1 0
        simulate 0 1 1 1 0
        simulate 0 1 1 0 0
        simulate 0 0 1 1 0
        simulate 0 1 1 1 0
        simulate 1 1 1 1 0
        simulate 1 0 0 1 0
        quit
      \end{lstlisting}
		\end{minipage}
		\hspace{0.05\linewidth}
		\begin{minipage}{0.45\linewidth}
			\textbf{output\_sis.txt}:
			\begin{lstlisting}[language=sh]


        Outputs: 0 0 0 0
        Outputs: 1 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 1 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 1 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 1 0 0 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 0 0
        Outputs: 1 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 1

      \end{lstlisting}
		\end{minipage}
	\end{minipage}
\end{figure}

\subsection{Verilog}
Nel testbench in verilog sono stati inseriti dei \$display() che mostrano i valori delle variabili in ogni ciclo di clock.
Di seguito è riportato l'output dei display nel testbench in verilog:
\begin{lstlisting}
  # run -all
  # Partita 1
  # Primo: 00 Secondo: 10 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 10 Manche: 10 Partita: 00
  # Primo: 11 Secondo: 10 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 01 Partita: 00
  # Primo: 11 Secondo: 11 Manche: 11 Partita: 00
  # Primo: 11 Secondo: 10 Manche: 01 Partita: 00
  # Primo: 01 Secondo: 10 Manche: 10 Partita: 00
  # Primo: 11 Secondo: 11 Manche: 11 Partita: 11
  # 
  # Partita 2
  # Primo: 00 Secondo: 01 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 01 Partita: 00
  # Primo: 10 Secondo: 01 Manche: 01 Partita: 00
  # Primo: 01 Secondo: 10 Manche: 10 Partita: 00
  # Primo: 10 Secondo: 11 Manche: 10 Partita: 00
  # Primo: 11 Secondo: 01 Manche: 10 Partita: 10
  # 
  # Partita 3
  # Primo: 11 Secondo: 11 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 01 Partita: 00
  # Primo: 10 Secondo: 01 Manche: 01 Partita: 00
  # Primo: 11 Secondo: 10 Manche: 01 Partita: 00
  # Primo: 11 Secondo: 01 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 10 Manche: 10 Partita: 01
  # 
  # Partita 4
  # Primo: 01 Secondo: 01 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 01 Partita: 00
  # Primo: 10 Secondo: 01 Manche: 01 Partita: 00
  # Primo: 11 Secondo: 01 Manche: 10 Partita: 00
  # Primo: 10 Secondo: 10 Manche: 11 Partita: 00
  # Primo: 11 Secondo: 01 Manche: 10 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 01 Partita: 00
  # Primo: 01 Secondo: 10 Manche: 00 Partita: 00
  # Primo: 00 Secondo: 11 Manche: 00 Partita: 00
  # Primo: 01 Secondo: 11 Manche: 00 Partita: 00
  # Primo: 11 Secondo: 11 Manche: 11 Partita: 00
  # Primo: 10 Secondo: 01 Manche: 01 Partita: 01
  # ** Note: $finish    : testbench.sv(381)
\end{lstlisting}

\subsection{Confronto}
Di seguito è riportato il confronto tra i due output. Si nota che sono identici perchè il modello in sis 
è stato progettato in modo da rispettare il modello in Verilog.

\begin{figure}[H]
	\centering
	\begin{minipage}{\linewidth}
		\centering
		\begin{minipage}{0.45\linewidth}
			\textbf{output\_sis.txt}:
			\begin{lstlisting}[language=bash]

        Outputs: 0 0 0 0
        Outputs: 1 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 1 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 1 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 1 0 0 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 0 0
        Outputs: 1 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 1
      \end{lstlisting}
		\end{minipage}
		\hspace{0.05\linewidth}
		\begin{minipage}{0.45\linewidth}
			\textbf{output\_verilog.txt}:
			\begin{lstlisting}[language=sh]

        Outputs: 0 0 0 0
        Outputs: 1 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 1 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 0 0
        Outputs: 1 0 1 0
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 1 0 0 1
        Outputs: 0 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 1 0 0
        Outputs: 1 0 0 0
        Outputs: 1 1 0 0
        Outputs: 1 0 0 0
        Outputs: 0 1 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 0 0 0 0
        Outputs: 1 1 0 0
        Outputs: 0 1 0 1
      \end{lstlisting}
		\end{minipage}
	\end{minipage}
\end{figure}


\section{Statistiche del circuito}

\subsection{Prima della minimizzazione}
Le statistiche della FSM prima della minimizzazione sono le seguenti:
\begin{lstlisting}
  sis> print_stats
  controllo       pi= 5   po= 2   nodes=  2       latches= 0
  lits(sop)=   0  #states(STG)=   7
  sis> state_assign jedi
  Running jedi, written by Bill Lin,  UC Berkeley
  sis> print_stats
  controllo       pi= 5   po= 2   nodes=  5       latches= 3
  lits(sop)= 379  #states(STG)=   7
\end{lstlisting}

\noindent Le statistiche del Datapath prima della minimizzazione sono le seguenti:
\begin{lstlisting}
  sis> print_stats
  elaborazione    pi= 7   po= 2   nodes=150       latches=14
  lits(sop)= 606
\end{lstlisting}

\noindent Le statitiche della FSMD prima della minimizzazione sono le seguenti:
\begin{lstlisting}
  sis> print_stats
  MorraCinese     pi= 5   po= 4   nodes=155       latches=17
  lits(sop)= 985
\end{lstlisting}

\subsection{Dopo la minimizzazione}

\subsubsection{Minimizzazione degli stati}
\begin{lstlisting}
  sis> read_blif controllo.blif
  sis> state_minimize stamina
  Running stamina, written by June Rho, University of Colorado at Boulder
  Number of states in original machine : 7
  Number of states in minimized machine : 7
  sis> state_assign jedi
  Running jedi, written by Bill Lin,  UC Berkeley
  sis> stg_to_network
  sis> print_stats
  controllo       pi= 5   po= 2   nodes=  5       latches= 3
  lits(sop)= 379  #states(STG)=   7
  sis> full_simplify
  sis> print_stats
  controllo       pi= 5   po= 2   nodes=  5       latches= 3
  lits(sop)= 152  #states(STG)=   7
  sis> source script.rugged
  sis> print_stats
  controllo       pi= 5   po= 2   nodes= 11       latches= 3
  lits(sop)= 109  #states(STG)=   7
  sis> write_blif controlloMinimizzato.blif
\end{lstlisting}

\subsubsection{Minimizzazione per area}
Dopo aver minimizzato gli stati della FSM, abbiamo minimizzato il circuito dell'elaborazione eseguendo le
seguenti operazioni:
\begin{lstlisting}
  sis> print_stats
  elaborazione    pi= 7   po= 2   nodes=150       latches=14
  lits(sop)= 606
  sis> full_simplify
  sis> print_stats
  elaborazione    pi= 7   po= 2   nodes=150       latches=14
  lits(sop)= 231
  sis> source script.rugged
  sis> print_stats
  elaborazione    pi= 7   po= 2   nodes= 33       latches=14
  lits(sop)= 188
  sis> write_blif elaborazioneMinimizzato.blif
\end{lstlisting}

\noindent Dopo aver minimizzato sia la FSM che il Datapath, abbiamo minimizzato il circuito finale eseguendo le
seguenti operazioni:
\begin{lstlisting}
  sis> print_stats
  MorraCinese     pi= 5   po= 4   nodes= 44       latches=17
  lits(sop)= 297
  sis> full_simplify
  sis> print_stats
  MorraCinese     pi= 5   po= 4   nodes= 44       latches=17
  lits(sop)= 285
\end{lstlisting}
\noindent Non abbiamo eseguito anche lo script \emph{script.rugged} in quanto avremmo ottenuto un letterale e un nodo
in più rispetto alla sola \emph{full\_simplify}.

\section{Numero di gate e ritardo}
Di seguito sono riportate le statistiche del circuito implementato in sis riguardanti il numero di gate e il ritardo.

\subsection{Prima della minimizzazione}
Le statistiche di numero di gate e ritardo della FSMD prima della minimizzazione sono le seguenti:
\vspace{1em}
\begin{lstlisting}
  sis> read_library synch.genlib
  sis> map -m 0 -s -W
  >>> before removing serial inverters <<<
  # of outputs:          21
  total gate area:       7268.00
  maximum arrival time: (39.80,39.80)
  maximum po slack:     (-3.40,-3.40)
  minimum po slack:     (-39.80,-39.80)
  total neg slack:      (-455.40,-455.40)
  # of failing outputs:  21
  >>> before removing parallel inverters <<<
  # of outputs:          21
  total gate area:       7268.00
  maximum arrival time: (39.80,39.80)
  maximum po slack:     (-3.40,-3.40)
  minimum po slack:     (-39.80,-39.80)
  total neg slack:      (-455.40,-455.40)
  # of failing outputs:  21
  # of outputs:          21
  total gate area:       7044.00
  maximum arrival time: (39.80,39.80)
  maximum po slack:     (-3.40,-3.40)
  minimum po slack:     (-39.80,-39.80)
  total neg slack:      (-457.40,-457.40)
  # of failing outputs:  21
\end{lstlisting}
\noindent Le statistiche di numero di gate e ritardo del Datapath prima della minimizzazione sono le seguenti:
\begin{itemize}
  \item \textbf{Total gate area}: \( 7044 \) ;
  \item \textbf{Maximum arrival time (cammino critico)}: \( 39.80 \) ;
\end{itemize}

\subsection{Dopo la minimizzazione per area}
Le statistiche di numero di gate e ritardo della FSMD dopo la minimizzazione per area sono le seguenti:
\begin{lstlisting}
  sis> read_library synch.genlib
  sis> map -m 0 -s -W
  >>> before removing serial inverters <<<
  # of outputs:          21
  total gate area:       5564.00
  maximum arrival time: (46.20,46.20)
  maximum po slack:     (-3.20,-3.20)
  minimum po slack:     (-46.20,-46.20)
  total neg slack:      (-534.60,-534.60)
  # of failing outputs:  21
  >>> before removing parallel inverters <<<
  # of outputs:          21
  total gate area:       5500.00
  maximum arrival time: (46.20,46.20)
  maximum po slack:     (-3.20,-3.20)
  minimum po slack:     (-46.20,-46.20)
  total neg slack:      (-534.60,-534.60)
  # of failing outputs:  21
  # of outputs:          21
  total gate area:       5244.00
  maximum arrival time: (44.40,44.40)
  maximum po slack:     (-3.20,-3.20)
  minimum po slack:     (-44.40,-44.40)
  total neg slack:      (-508.60,-508.60)
  # of failing outputs:  21
\end{lstlisting}
\noindent Le statistiche di numero di gate e ritardo del Datapath dopo la minimizzazione per area sono le seguenti:
\begin{itemize}
  \item \textbf{Total gate area}: \( 5244 \) ;
  \item \textbf{Maximum arrival time (cammino critico)}: \( 44.40 \) ;
\end{itemize}

\section{Scelte progettuali}
\subsection{FSM}
Nello sviluppo di questo circuito abbiamo pensato di implementare il calcolo della manche all'interno della
FSM in modo da avere un circuito più semplice e con meno componenti, risparmiandoci così di memorizzare
all'interno del Datapath il vincitore di ogni manche e la mossa che ha usato per vincere.

\subsection{Datapath}
\subsubsection{Concatenatori}
I componenti dei concatenatori sono stati inseriti nel datapath a scopo puramente illustrativo, in quanto
non sono stati utilizzati per la realizzazione del circuito siccome in sis è possibile gestire i bit singolarmente
e quindi inserirli direttamente nei componenti che li utilizzano nell'ordine desiderato.

\noindent In verilog, invece,
è possibile utilizzare l'operatore di concatenazione.

\subsubsection{Componenti riutilizzati}
Per la realizzazione del datapath abbiamo cercato di riutilizzare il più possibile i componenti già realizzati per il circuito
evitando di crearne di nuovi, ad esempio abbiamo utilizzato solo il componente \textbf{Maggiore Uguale} per 
tutti i controlli necessari all'interno del componente \textbf{Partita}.

\noindent Per quanto riguarda il resto dei componenti abbiamo dovuto crearne di nuovi in quanto il numero di
bit del registro \textbf{vantaggio} e il numero di bit dei registri \textbf{mancheIdx} e \textbf{maxManche}
sono diversi. Avremmo potuto considerare \textbf{vantaggio} da 5 bit per poter riutilizzare componenti già presenti,
ma abbiamo preferito ottimizzare il circuito scegliendo il minor numero di bit necessari per ogni componente.

\subsection{Warning}
Simulando il circuito in sis vengono generati dei warning riguardanti le uscite che non vengono utilizzate, come
ad esempio i riporti dei sommatori. Questi warning possono essere ignorati in quanto non influiscono sul funzionamento
del circuito.
\end{document}
